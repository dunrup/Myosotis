/*

 Morphology dict format:

 block = chunk,chunk
 chunk = lemma,entry,entry...\n
 entry = form @ morph
 morph = pos (1b) morph-values (8b) features (0..Xb)

 */


var kValues = {
    'case': ['nom', 'gen', 'dat', 'acc', 'abl', 'voc', 'loc', 'ins'],
    'degree': ['pos', 'comp', 'superl'],
    'dialect': ['aeolic', 'attic', 'doric', 'epic', 'homeric', 'ionic', 'parad_form', 'prose', 'poetic'],
    'gender': ['masc', 'fem', 'neut'],
    'mood': ['ind', 'subj', 'opt', 'inf', 'imperat', 'gerundive', 'supine', 'gerund'],
    'number': ['sg', 'pl', 'dual'],
    'person': ['1st', '2nd', '3rd'],
    'pos': ['noun', 'verb', 'part', 'adj', 'adv', 'adverbial', 'article', 'partic', 'conj', 'prep', 'pron', 'numeral', 'interj', 'exclam', 'punc', 'irreg', 'func'],
    'tense': ['pres', 'imperf', 'perf', 'plup', 'futperf', 'fut', 'aor', 'pastabs'],
    'voice': ['act', 'pass', 'dep', 'mid', 'mp']
};

var kKeys = ['mood', 'voice', 'tense', 'degree', 'gender', 'number', 'case', 'person'];

var kPos = ['noun',
    'verb',
    'participle',
    'adjective',
    'adverb',
    'adverbial',
    'article',
    'particle',
    'conjunction',
    'preposition',
    'pronoun',
    'numeral',
    'interjection',
    'exclamation',
    'punctuation',
    'irregular',
    'functional'];

var kFeatures = [
    'aeolic',
    'attic',
    'doric',
    'epic',
    'homeric',
    'ionic',
    'parad_form',
    'poetic',
    'prose',

    'a_copul',
    'a_priv',
    'apocope',
    'attic_redupl',
    'causal',
    'comp_only',
    'contr',
    'desiderative',
    'diminutive',
    'dissimilation',
    'double_aug',
    'doubled_cons',
    'early',
    'elide_preverb',
    'en_to_eni',
    'enclitic',
    'ends_in_dig',
    'frequentat',
    'geog_name',
    'impersonal',
    'indeclform',
    'intrans',
    'iota_intens',
    'irreg_comp',
    'irreg_superl',
    'iterative',
    'late',
    'later',
    'meta_to_peda',
    'metath',
    'n_infix',
    'no_circumflex',
    'no_redupl',
    'nu_movable',
    'para_to_parai',
    'pres_redupl',
    'prevb_aug',
    'proclitic',
    'pros_to_poti',
    'pros_to_proti',
    'r_e_i_alpha',
    'rare',
    'raw_preverb',
    'raw_sonant',
    'redupl',
    'root_preverb',
    'short_eis',
    'short_subj',
    'sig_to_ci',
    'syll_augment',
    'syncope',
    'unasp_preverb',
    'unaugmented',
    'uncontr',
    'uper_to_upeir',
    'upo_to_upai'
];

function n2s(n) { return String.fromCharCode(0x48 + n) }
function s2n(s) { return s.charCodeAt(0) - 0x48 }


function encode(e) {
    var pos = n2s(1 + kValues.pos.indexOf(e.pos));

    var morph = kKeys.map(function(x) {
        return e[x] ? n2s(1 + kValues[x].indexOf(e[x])) : "0";
    }).join("");

    var feats = [];
    (e.dialect || "" + " " + e.feature || "").split(" ").forEach(function(x) {
        x = kFeatures.indexOf(x);
        if(x >= 0)
            feats.push(n2s(1 + x));
    });
    return [pos + morph, feats.sort().join("")];
}

function decode(buf) {

    var o = 0, e = {pos: kPos[s2n(buf[o++]) - 1], feature: []};

    kKeys.forEach(function(k, i)  {
        var v = buf[o++];
        if(v !== "0")
            e[kKeys[i]] = kValues[kKeys[i]][s2n(v) - 1];
    });

    while(o < buf.length)
        e.feature.push(kFeatures[s2n(buf[o++]) - 1]);
    e.feature = e.feature.join(" ");

    return e;
}

function render(e, renderGreek) {
    var html = "";

    function table(pos, forms) {
        var keys = kKeys.filter(function(k) {
            return forms.some(function(f) { return f[k] });
        });

        var rows = [];
        forms.forEach(function(f) {
            var props = keys.map(function(k) {
                return $f("<td class='m'>{0}</td>", f[k] || "");
            }).join("");

            var len = rows.length;
            var g = renderGreek(f.form, f.feature);
            if(len && rows[len - 1].props == props)
                rows[len - 1].forms.push(g);
            else
                rows.push({props:props, forms:[g]});
        });

        var head = $f("<tr class='head'><td colspan='{0}'>{1}</td></tr>",
            keys.length + 1,
            pos);

        return head + rows.map(function(row) {
            return $f("<tr>{0}<td class='w'>{1}</td></tr>", row.props, row.forms.join(" "));
        }).join("\n");
    }


    var byPos = {};

    e.val.forEach(function(v) {
        var pos = v.pos;
        if(!byPos[pos]) byPos[pos] = [];
        byPos[pos].push(v);
    });

    Object.keys(byPos).forEach(function(pos) {
        html += "<table>";
        html += table(pos, byPos[pos]);
        html += "</table>"
    });

    return html;

}

// Reading

var d = require("dictbase");

function parseBlock(b) {
    var r = [];
    b.split("\n").forEach(function(s) {
        var forms = [];
        s = s.split(",");
        s.slice(1).map(function(f) {
            f = f.split("#");
            var e = decode(f[1]);
            e.form = f[0];
            forms.push(e);
        });
        r.push({
            key: s[0],
            val: forms
        });
    });
    return r;
}

var _dict = null;

function openRead(dir) {
    _dict = new d.Dict("morph", dir).openRead();
    _dict.parseBlock = parseBlock;
    return module.exports;
}

// Writing

var _wdict = null;

function openWrite(dir) {
    _wdict = new d.Dict("morph", dir, 0xFFFF).openWrite();
    return module.exports;
}

function write(lemma, entries) {
    var w = {};
    entries.forEach(function(e) {
        var enc = encode(e);
        w[e.form + "#" + enc[0]] = [e.form, enc[0], enc[1]];
    });

    entries = Object.keys(w).map(function(x) {
        return w[x]
    }).sort(function(x, y) {
        // sort by morphology, then by form
        return d.cmp(x[1], y[1]) || d.keycmp(x[0], y[0]);
    }).map(function(x) {
        return x[0] + "#" + x[1] + x[2];
    }).join(",");

    _wdict.addString(lemma, lemma + "," + entries);
}

function closeWrite() {
    _wdict.closeWrite();
}

module.exports = {
    openRead: openRead,
    render: render,
    lookup: function(e) { return _dict.lookup(e) },
    openWrite: openWrite,
    write: write,
    closeWrite: closeWrite
};
