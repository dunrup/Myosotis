/*
    Dictionaries:
        index file idx
        data file  dat

    Index file:

        JSON list of blocks: [min-key, max-key, offset, length]

    Data file:

        data  = block, block...
        block = chunk, chunk...

    Each dict has a `parseBlock` func that parses chunks into arrays of entries:

        chunk = [entry,entry,...]
        entry = {key:xxxx, val:xxxx}
 */

function Dict(name, dir, maxLen) {

    var idx = [];
    var fs = require("fs");
    var greek = require("greek");

    this.openRead = function() {
        var s = fs.readFileSync(dir + "/" + name + ".idx", {encoding:"ascii"});
        idx = JSON.parse(s);
        return this;
    };

    this.findBlock = function(k) {
        for(var i = 0; i < idx.length; i++) {
            var b = idx[i];
            if(k >= b[0] && k <= b[1])
                return b;
        }
        return null;
    };

    this.readBlock = function(b) {
        var buf = new Buffer(b[3]);
        var fp = fs.openSync(dir + "/" + name + ".dat", "r");
        fs.readSync(fp, buf, 0, b[3], b[2]);
        fs.closeSync(fp);
        return this.parseBlock(buf.toString());
    };

    this.lookup = function(word) {
        var b = this.findBlock(word);
        if(!b)
            return [];

        var nword = word.replace(/\d+/g, "");
        var x = [], y = [];

        this.readBlock(b).every(function(chunk) {
            if(chunk.key == word) {
                x.push(chunk);
                return true;
            }
            if(chunk.key.replace(/\d+/g, "") == nword) {
                y.push(chunk);
                return true;
            }
            return (chunk.key < word);
        });

        return x.concat(y);
    };

    var fdat, fpos = 0;
    var strs = [],  keys = [], len = 0;

    this.openWrite = function() {
        fdat = fs.openSync(dir + "/" + name + ".dat", "w");
        return this;
    };

    this.addString = function(key, str) {
        if(len >= maxLen)
            this.flush();
        len += str.length;
        strs.push(str);
        keys.push(key);
    };

    this.flush = function(key, str) {
        var siz = len + strs.length, buf = new Buffer(siz), o = 0;

        strs.forEach(function(str) {
            var len = str.length;
            buf.write(str, o, len, "ascii");
            o += len;
            buf.writeInt8(0x0A, o++);
        });

        idx.push([keys[0], keys[keys.length - 1], fpos, siz]);
        fs.writeSync(fdat, buf, 0, buf.length);
        fpos += siz;

        strs = [];
        keys = [];
        len = 0;
    };

    this.closeWrite = function() {
        this.flush();
        fs.closeSync(fdat);

        var fp = fs.openSync(dir + "/" + name + ".idx", "w");
        fs.writeSync(fp, JSON.stringify(idx));
        fs.closeSync(fp);
    };
}

function mkey(s) {
    return s.replace(/[^a-z]/g, "").replace(/\d+$/g, "");
}

function cmp(x, y) {
    return x > y ? 1 : x < y ? -1 : 0
}

function uniq(a) {
    var s = {};

    return a.filter(function(x) {
        return !s[x] || (s[x] = 1);
    });
}

module.exports = {
    Dict: Dict,
    mkey: mkey,
    cmp: cmp,
    keycmp: function (x, y) { return cmp(mkey(x), mkey(y)) },
    uniq: uniq
};

