/*

 ML dict format:

 block = chunk,chunk
 chunk = lemma \x01 text \n

 */

function render(e, renderGreek) {


    function entry(xml) {

        var langs = [], notes = [];

        function wrap(tag, e) {
            var s = "";
            if(tag)
                s += "<" + tag + ">";
            s += [].map.call(e.childNodes, convert).join("");
            if(tag)
                s += "</" + tag.split(" ")[0] + ">";
            return s;
        }

        function convertTag(e) {
            switch(e.tagName) {
                case "form":
                    return wrap("h4", e);
                case "sense":
                    var n = e.getAttribute("n");
                    return  $f("<p class='level{0}'><span class='num'>{1}</span> {2}</p>",
                        e.getAttribute("level") || 0,
                        n && n !== "0" ? n + "." : "",
                        wrap("", e));
                case "note":
                    notes.push(wrap("span", e));
                    return "";
                case "etym":    return wrap("p class='etym'", e);
                case "trans":   return wrap("span class='tr'", e);
                case "foreign": return wrap("span class='ref'", e);
                case "usg":     return wrap("span class='usg'", e);
                case "ref":     return wrap("span class='ref'", e);
                case "xr":      return wrap("span class='ref'", e);

                default: return wrap("", e);
            }

        }

        function convert(e) {
            if(e.nodeType == 3) {
                var s = e.nodeValue;
                if(langs[langs.length - 1] == "greek")
                    s = renderGreek(s)
                return s;
            }
            langs.push(e.getAttribute("lang"));
            var s = convertTag(e);
            langs.pop();
            return s;
        }

        xml = xml.replace(/&/g, "@");
        var doc = new DOMParser().parseFromString(xml, "text/xml");
        xml = convert(doc.documentElement);
        xml = xml.replace(/@/g, "&");
        if(notes.length)
            xml += "<p class='notes'>" + notes.join(" ") + "</p>";
        return xml;
    }

    return entry("<x>" + e.val + "</x>");
}


var d = require("dictbase");

// Reading

var _dict = null;

function parseBlock(b) {
    var r = [];
    b.split("\n").forEach(function(s) {
        s = s.split("#");
        r.push({key: s[0], val: s[1] });
    });
    return r;
}


function openRead(dir) {
    _dict = new d.Dict("ml", dir).openRead();
    _dict.parseBlock = parseBlock;
    return module.exports;
}


// Writing

var _wdict = null;

function openWrite(dir) {
    _wdict = new d.Dict("ml", dir, 0xFFFF).openWrite();
    return module.exports;
}

function write(lemma, text) {
    text = text.replace(/[\r\n]+/g, " ");
    text = text.replace(/#/g, " ");
    text = text.replace(/\s+/g, " ");

    _wdict.addString(lemma, lemma + "#" + text);
}

function closeWrite() {
    _wdict.closeWrite();
}

module.exports = {
    openRead: openRead,
    render: render,
    lookup: function(e) { return _dict.lookup(e) },
    openWrite: openWrite,
    write: write,
    closeWrite: closeWrite
};
